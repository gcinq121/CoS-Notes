"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableSort
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  isEnabled: true,
  isDevmodeEnabled: false
};
var TableSortSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const general_heading = containerEl.createEl("div");
    general_heading.createEl("h2", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Toggle table sorting").setDesc("This toggles the activation state of this plugin.").addToggle((toggle) => {
      toggle.setDisabled(false).setValue(TableSort.settings.isEnabled).onChange(async (value) => {
        TableSort.settings.isEnabled = value;
        await this.plugin.saveSettings();
      });
    });
    const developer_heading = containerEl.createEl("div");
    developer_heading.createEl("h2", { text: "Developer Settings" });
    new import_obsidian.Setting(containerEl).setName("Developer mode").setDesc("This enables development logging in the console.").addToggle((toggle) => {
      toggle.setDisabled(false).setValue(TableSort.settings.isDevmodeEnabled).onChange(async (value) => {
        TableSort.settings.isDevmodeEnabled = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/column.ts
var Column = class {
  constructor(id, element, order = "neutral") {
    this.id = id;
    this.element = element;
    this.order = order;
  }
  getName() {
    return this.element.innerHTML;
  }
  getWeight() {
    if (this.order == "neutral") {
      return 0;
    }
    return this.order == "ascending" ? 1 : -1;
  }
  reset() {
  }
  setIcon() {
    this.element.classList.remove("neutral");
    this.element.classList.remove("ascending");
    this.element.classList.remove("descending");
    this.element.classList.add(this.order);
  }
  setLabel(label) {
    TableSort.log("Setting '" + this.getName() + "' to " + label, this.order);
    this.element.setAttribute("data-content", label);
  }
  update() {
    this.order = this.order === "neutral" ? "descending" : this.order === "ascending" ? "neutral" : "ascending";
    this.setIcon();
    return this.order;
  }
};

// src/table.ts
var Table = class {
  constructor(id, element, plugin) {
    this.id = id || 0;
    this.element = element;
    this.plugin = plugin;
    this.filters = [];
    this.columns = [];
    this.column = -1;
    this.filters = [];
    element.setAttribute("id", id.toString());
    this.currentOrder = this.getTableRows();
    this.originalOrder = this.currentOrder;
  }
  _resetOtherColumns(column) {
    this.columns.forEach((e) => {
      if (e !== column) {
        e.order = "neutral";
        e.setLabel("");
      } else {
        column.update();
      }
      e.setIcon();
    });
  }
  _revertColumn(column) {
    this.filters.splice(this.filters.indexOf(column), 1);
    column.setLabel("");
  }
  _updateLabels() {
    this.filters.forEach((e, i) => {
      e.setLabel("(" + i.toString() + ")");
      e.setIcon();
    });
  }
  handleClick(column, isPressingCtrl) {
    const isRegistered = this.filters.includes(column);
    if (!isPressingCtrl) {
      if (!isRegistered) {
        column.order = "neutral";
      }
      this.filters = [column];
      this._resetOtherColumns(column);
    } else {
      if (!isRegistered) {
        column.order = "neutral";
        this.filters.push(column);
      }
      column.update();
    }
    if (column.order == "neutral") {
      this._revertColumn(column);
    }
    this._updateLabels();
  }
  fillTable() {
    this.currentOrder.forEach((row) => {
      var _a;
      (_a = this.element.querySelector("tbody")) == null ? void 0 : _a.appendChild(row);
    });
  }
  getColumnDataAt(id) {
    const element = this.getTableHeads()[id];
    if (!this.columns[id]) {
      const column = new Column(id, element, "neutral");
      this.columns[id] = column;
      return column;
    }
    return this.columns[id];
  }
  getColumnIndex(th) {
    this.updateElement();
    return Array.prototype.indexOf.call(this.getTableHeads(), th);
  }
  getTableHeads() {
    var _a;
    this.updateElement();
    return Array.from((_a = this.element) == null ? void 0 : _a.querySelectorAll("th"));
  }
  getTableRows() {
    this.updateElement();
    const rowElements = this.element.querySelectorAll("tr");
    return Array.from(rowElements).splice(1, rowElements.length);
  }
  removeRows(rows) {
    Array.from(rows).forEach((row) => {
      row.remove();
    });
  }
  sort() {
    const compareRows = (rowA, rowB) => {
      for (const filter of this.filters) {
        const cellA = rowA.children[filter.id];
        const cellB = rowB.children[filter.id];
        if (!cellA || !cellB) {
          return 0;
        }
        const valueA = cellA.textContent ? cellA.textContent.toLowerCase() : false;
        const valueB = cellB.textContent ? cellB.textContent.toLowerCase() : false;
        if (valueA < valueB || valueA == false) {
          return -1 * filter.getWeight();
        }
        if (valueA > valueB || valueB == false) {
          return 1 * filter.getWeight();
        }
      }
      return 0;
    };
    if (this.filters.length == 0) {
      this.currentOrder = this.originalOrder;
    } else {
      this.currentOrder = Array.from(this.currentOrder).sort((rowA, rowB) => {
        return compareRows(rowA, rowB);
      });
      TableSort.log("[obsidian-table-sorting] sort() - Finished sorting trows.");
    }
    this.fillTable();
  }
  updateElement() {
    const element = document.getElementById(this.id.toString());
    if (!element) {
      console.error("Found no registered table with the corresponding id.");
    }
  }
};

// src/mouseHandler.ts
function getMousedownHandler(plugin) {
  return async (evt) => {
    if (evt.target == null) {
      return;
    }
    const element = evt.target;
    if (element.tagName !== "TH") {
      return;
    }
    const tableElement = plugin.getTableElement(element);
    if (!tableElement || plugin.hasCustomClasses(tableElement)) {
      return;
    }
    evt.preventDefault();
    const tableID = plugin.getTableID(tableElement);
    let table;
    if (plugin.isNewTable(tableID)) {
      table = new Table(tableID, tableElement, plugin);
      plugin.storage.push(table);
    } else {
      table = plugin.storage[tableID];
    }
    const columnIndex = table.getColumnIndex(element);
    const column = table.getColumnDataAt(columnIndex);
    table.handleClick(column, evt.ctrlKey == true);
    table.sort();
  };
}

// main.ts
var TableSort = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.storage = [];
  }
  *autoIncrement() {
    let index = 0;
    while (true) {
      yield index++;
    }
  }
  getTableElement(th) {
    return th.closest("table") || void 0;
  }
  getTableID(table) {
    var _a;
    const id = (_a = table.getAttribute("id")) == null ? void 0 : _a.replace("table-", "");
    return id ? parseInt(id) : this.gen.next().value;
  }
  hasCustomClasses(table) {
    const classes = table.getAttribute("class") || "";
    if (classes.length > 0) {
      return true;
    }
    return false;
  }
  isNewTable(id) {
    return this.storage.length - 1 >= id ? false : true;
  }
  async loadSettings() {
    TableSort.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  static log(out, ...optionalParams) {
    if (this.settings.isDevmodeEnabled === false) {
      return;
    }
    console.log(out, optionalParams);
  }
  async saveSettings() {
    await this.saveData(TableSort.settings);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TableSortSettingsTab(this.app, this));
    this.gen = this.autoIncrement();
    this.storage = [];
    const mousedownHandler = getMousedownHandler(this);
    this.registerDomEvent(document, "click", mousedownHandler, {
      capture: true
    });
    console.log("( obsidian-table-sorting ) Plugin has finished loading.");
  }
  onunload() {
    this.storage = [];
  }
};
